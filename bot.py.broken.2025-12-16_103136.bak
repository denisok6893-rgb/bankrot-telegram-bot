import asyncio
import os
import time
import uuid
from typing import Dict, Any, List, Tuple, Set

import aiohttp
from dotenv import load_dotenv

from aiogram import Bot, Dispatcher
from aiogram.filters import CommandStart, Command
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
import cases

load_dotenv()

ENV_PATH = "/root/bankrot_bot/.env"

BOT_TOKEN = os.getenv("BOT_TOKEN")
AUTH_KEY = os.getenv("GIGACHAT_AUTH_KEY")
SCOPE = os.getenv("GIGACHAT_SCOPE", "GIGACHAT_API_PERS")
MODEL = os.getenv("GIGACHAT_MODEL", "GigaChat-2-Pro")

RAW_ALLOWED = (os.getenv("ALLOWED_USERS") or "").strip()
RAW_ADMINS = (os.getenv("ADMIN_USERS") or "").strip()  # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
_GC_TOKEN = None
_GC_TOKEN_EXPIRES_AT = 0
_GC_TOKEN_LOCK = asyncio.Lock()


def parse_ids(raw: str) -> Set[int]:
    out: Set[int] = set()
    for part in raw.split(","):
        part = part.strip()
        if part.isdigit():
            out.add(int(part))
    return out


ALLOWED_USERS: Set[int] = parse_ids(RAW_ALLOWED)
ADMIN_USERS: Set[int] = parse_ids(RAW_ADMINS) if RAW_ADMINS else set(ALLOWED_USERS)

if not BOT_TOKEN or not AUTH_KEY:
    raise SystemExit("–û—à–∏–±–∫–∞: –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω .env (BOT_TOKEN / GIGACHAT_AUTH_KEY)")

dp = Dispatcher()
dp.include_router(cases.router)

USER_FLOW: Dict[int, Dict[str, Any]] = {}
LAST_RESULT: Dict[int, str] = {}

_token: str | None = None
_token_exp: int = 0


def is_allowed(user_id: int) -> bool:
    # –ü–æ–∫–∞ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º (–∑–∞—â–∏—Ç–∞ –æ—Ç —Å–ª—É—á–∞–π–Ω–æ–π –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏).
    return (not ALLOWED_USERS) or (user_id in ALLOWED_USERS)


def is_admin(user_id: int) -> bool:
    # –ï—Å–ª–∏ ADMIN_USERS –ø—É—Å—Ç ‚Äî –∞–¥–º–∏–Ω—ã = allowed
    if not ADMIN_USERS:
        return user_id in ALLOWED_USERS
    return user_id in ADMIN_USERS


def _write_env_key(key: str, value: str) -> None:
    # –∞—Ç–æ–º–∞—Ä–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ .env
    try:
        with open(ENV_PATH, "r", encoding="utf-8") as f:
            lines = f.read().splitlines()
    except FileNotFoundError:
        lines = []

    new_lines: List[str] = []
    replaced = False
    for line in lines:
        if line.startswith(f"{key}="):
            new_lines.append(f"{key}={value}")
            replaced = True
        else:
            new_lines.append(line)

    if not replaced:
        new_lines.append(f"{key}={value}")

    tmp = ENV_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        f.write("\n".join(new_lines) + "\n")
    os.replace(tmp, ENV_PATH)


def _sync_env_from_memory() -> None:
    allowed_str = ",".join(str(x) for x in sorted(ALLOWED_USERS))
    admins_str = ",".join(str(x) for x in sorted(ADMIN_USERS))
    _write_env_key("ALLOWED_USERS", allowed_str)
    _write_env_key("ADMIN_USERS", admins_str)


# ---------- keyboards ----------
def main_keyboard():
    kb = InlineKeyboardBuilder()
    kb.button(text="üßæ –•–æ–¥–∞—Ç–∞–π—Å—Ç–≤–æ (–æ–Ω–ª–∞–π–Ω/–í–ö–°)", callback_data="mode:motion")
    kb.button(text="üìÑ –ú–∏—Ä–æ–≤–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ", callback_data="mode:settlement")
    kb.button(text="‚ùì –í–æ–ø—Ä–æ—Å –ø–æ –±–∞–Ω–∫—Ä–æ—Ç—Å—Ç–≤—É", callback_data="mode:qa")
    kb.adjust(1)
    return kb.as_markup()


def court_type_keyboard():
    kb = InlineKeyboardBuilder()
    kb.button(text="üèõ –ê—Ä–±–∏—Ç—Ä–∞–∂", callback_data="court:arbitration")
    kb.button(text="‚öñ –°–û–Æ", callback_data="court:general")
    kb.adjust(2)
    return kb.as_markup()


def motion_actions_keyboard():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ß–µ—Ä–Ω–æ–≤–∏–∫ —Å–µ–π—á–∞—Å", callback_data="motion:generate_now")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="motion:cancel")
    kb.adjust(1)
    return kb.as_markup()


def settlement_actions_keyboard():
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ß–µ—Ä–Ω–æ–≤–∏–∫ —Å–µ–π—á–∞—Å", callback_data="settlement:generate_now")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="settlement:cancel")
    kb.adjust(1)
    return kb.as_markup()


def export_keyboard():
    kb = InlineKeyboardBuilder()
    kb.button(text="üìã –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è Word", callback_data="export:word")
    kb.adjust(1)
    return kb.as_markup()


# ---------- questionnaires ----------
MOTION_STEPS: List[Tuple[str, str]] = [
    ("court_name", "1/6. –£–∫–∞–∂–∏ —Å—É–¥ (–Ω–∞–∑–≤–∞–Ω–∏–µ)."),
    ("case_no", "2/6. –£–∫–∞–∂–∏ ‚Ññ –¥–µ–ª–∞."),
    ("applicant", "3/6. –ö—Ç–æ –ø–æ–¥–∞—ë—Ç —Ö–æ–¥–∞—Ç–∞–π—Å—Ç–≤–æ (–§–ò–û/–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è, —Å—Ç–∞—Ç—É—Å)?"),
    ("hearing_dt", "4/6. –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –∑–∞—Å–µ–¥–∞–Ω–∏—è (–µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ—à—å ‚Äî ¬´–Ω–µ –∑–Ω–∞—é¬ª)."),
    ("reason", "5/6. –ü—Ä–∏—á–∏–Ω–∞ –æ–Ω–ª–∞–π–Ω-—É—á–∞—Å—Ç–∏—è (–∫—Ä–∞—Ç–∫–æ, –ø–æ –¥–µ–ª—É)."),
    ("contacts_attachments", "6/6. –ö–æ–Ω—Ç–∞–∫—Ç—ã –¥–ª—è —Å–≤—è–∑–∏/–í–ö–° + –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–æ—Ä–¥–µ—Ä/–¥–æ–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å). –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî ¬´–Ω–µ—Ç¬ª."),
]

SETTLEMENT_STEPS: List[Tuple[str, str]] = [
    ("court_case", "1/7. –°—É–¥ –∏ ‚Ññ –¥–µ–ª–∞ (–º–æ–∂–Ω–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π)."),
    ("parties", "2/7. –°—Ç–æ—Ä–æ–Ω—ã (–∫—Ç–æ —Å –∫–µ–º –∑–∞–∫–ª—é—á–∞–µ—Ç –º–∏—Ä–æ–≤–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ)."),
    ("dispute", "3/7. –°—É—Ç—å —Å–ø–æ—Ä–∞/—á—Ç–æ —É—Ä–µ–≥—É–ª–∏—Ä—É–µ–º (1‚Äì3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)."),
    ("terms", "4/7. –£—Å–ª–æ–≤–∏—è: —Å—É–º–º–∞/–≥—Ä–∞—Ñ–∏–∫/—Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ)."),
    ("expenses", "5/7. –°—É–¥–µ–±–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã: –∫–∞–∫ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º (–∏–ª–∏ ¬´–∫–∞–∫ –æ–±—ã—á–Ω–æ/–ø–æ –∑–∞–∫–æ–Ω—É¬ª)."),
    ("execution", "6/7. –ü–æ—Ä—è–¥–æ–∫ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ ‚Äî ¬´—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ¬ª)."),
    ("other", "7/7. –û—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è (–µ—Å–ª–∏ –Ω–µ—Ç ‚Äî ¬´–Ω–µ—Ç¬ª)."),
]


def start_motion(uid: int):
    USER_FLOW[uid] = {"flow": "motion", "stage": "choose_court_type", "court_type": None, "step": 0, "answers": {}}


def start_settlement(uid: int):
    USER_FLOW[uid] = {"flow": "settlement", "stage": "fill", "step": 0, "answers": {}}


def cancel_flow(uid: int):
    USER_FLOW.pop(uid, None)


def system_prompt_for_motion(court_type: str) -> str:
    law = "–ê–ü–ö –†–§" if court_type == "arbitration" else "–ì–ü–ö –†–§"
    return (
        "–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –∞–¥–≤–æ–∫–∞—Ç–∞ –≤ –†–§. "
        "–°–æ—Å—Ç–∞–≤—å —Ö–æ–¥–∞—Ç–∞–π—Å—Ç–≤–æ –æ–± —É—á–∞—Å—Ç–∏–∏ –≤ —Å—É–¥–µ–±–Ω–æ–º –∑–∞—Å–µ–¥–∞–Ω–∏–∏ –≤ —Ä–µ–∂–∏–º–µ –í–ö–°/–æ–Ω–ª–∞–π–Ω. "
        f"–û—Ä–∏–µ–Ω—Ç–∏—Ä—É–π—Å—è –Ω–∞ {law}. "
        "–ü–∏—à–∏ —Å—Ç—Ä–æ–≥–æ —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–º —è–∑—ã–∫–æ–º. –ù–µ –≤—ã–¥—É–º—ã–≤–∞–π —Ä–µ–∫–≤–∏–∑–∏—Ç—ã. "
        "–ï—Å–ª–∏ —Ç–æ—á–Ω—ã–µ –Ω–æ—Ä–º—ã –Ω–µ —É–≤–µ—Ä–µ–Ω ‚Äî —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è —Å—Ç–∞—Ç–µ–π. "
        "–°—Ç—Ä—É–∫—Ç—É—Ä–∞: —à–∞–ø–∫–∞, –¥–∞–Ω–Ω—ã–µ –¥–µ–ª–∞, –æ–±—Å—Ç–æ—è—Ç–µ–ª—å—Å—Ç–≤–∞, –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ, –ø—Ä–æ—Å—å–±–∞, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –ø–æ–¥–ø–∏—Å—å/–¥–∞—Ç–∞."
    )


def system_prompt_for_settlement() -> str:
    return (
        "–¢—ã ‚Äî –ø–æ–º–æ—â–Ω–∏–∫ –∞–¥–≤–æ–∫–∞—Ç–∞ –≤ –†–§. "
        "–ü–æ–¥–≥–æ—Ç–æ–≤—å –ø—Ä–æ–µ–∫—Ç –º–∏—Ä–æ–≤–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è –¥–ª—è —Å—É–¥–∞ (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ). "
        "–ü–∏—à–∏ —é—Ä–∏–¥–∏—á–µ—Å–∫–∏–º —è–∑—ã–∫–æ–º, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–æ, –±–µ–∑ –≤—ã–¥—É–º–æ–∫. "
        "–ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç ‚Äî –æ—Å—Ç–∞–≤—å –º–µ—Å—Ç–∞ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è."
    )


def _val(ans: Dict[str, str], key: str) -> str:
    v = (ans.get(key) or "").strip()
    return v if v else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"


def build_motion_user_text(ans: Dict[str, str], court_type: str, draft: bool) -> str:
    prefix = "–°–î–ï–õ–ê–ô –ß–ï–†–ù–û–í–ò–ö (–¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–ø–æ–ª–Ω—ã–º–∏). " if draft else ""
    ct = "–ê—Ä–±–∏—Ç—Ä–∞–∂" if court_type == "arbitration" else "–°–û–Æ"
    return (
        f"{prefix}–¢–∏–ø —Å—É–¥–∞: {ct}\n"
        f"–°—É–¥: {_val(ans,'court_name')}\n"
        f"‚Ññ –¥–µ–ª–∞: {_val(ans,'case_no')}\n"
        f"–ó–∞—è–≤–∏—Ç–µ–ª—å: {_val(ans,'applicant')}\n"
        f"–ó–∞—Å–µ–¥–∞–Ω–∏–µ: {_val(ans,'hearing_dt')}\n"
        f"–ü—Ä–∏—á–∏–Ω–∞ –æ–Ω–ª–∞–π–Ω-—É—á–∞—Å—Ç–∏—è: {_val(ans,'reason')}\n"
        f"–ö–æ–Ω—Ç–∞–∫—Ç—ã/–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: {_val(ans,'contacts_attachments')}\n"
        "–ï—Å–ª–∏ –µ—Å—Ç—å ¬´–Ω–µ —É–∫–∞–∑–∞–Ω–æ¬ª, –æ—Å—Ç–∞–≤—å –º–µ—Å—Ç–æ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è."
    )


def build_settlement_user_text(ans: Dict[str, str], draft: bool) -> str:
    prefix = "–°–î–ï–õ–ê–ô –ß–ï–†–ù–û–í–ò–ö (–¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–ø–æ–ª–Ω—ã–º–∏). " if draft else ""
    return (
        f"{prefix}"
        f"–°—É–¥/–¥–µ–ª–æ: {_val(ans,'court_case')}\n"
        f"–°—Ç–æ—Ä–æ–Ω—ã: {_val(ans,'parties')}\n"
        f"–°—É—Ç—å —É—Ä–µ–≥—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è: {_val(ans,'dispute')}\n"
        f"–£—Å–ª–æ–≤–∏—è: {_val(ans,'terms')}\n"
        f"–†–∞—Å—Ö–æ–¥—ã: {_val(ans,'expenses')}\n"
        f"–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ/–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å: {_val(ans,'execution')}\n"
        f"–û—Å–æ–±—ã–µ —É—Å–ª–æ–≤–∏—è: {_val(ans,'other')}\n"
        "–ï—Å–ª–∏ –µ—Å—Ç—å ¬´–Ω–µ —É–∫–∞–∑–∞–Ω–æ¬ª, –æ—Å—Ç–∞–≤—å –º–µ—Å—Ç–æ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è."
    )


# ---------- gigachat ----------
async def get_access_token(session: aiohttp.ClientSession, force_refresh: bool = False) -> str:
    global _GC_TOKEN, _GC_TOKEN_EXPIRES_AT

    now = time.time()
    if (not force_refresh) and _GC_TOKEN and now < _GC_TOKEN_EXPIRES_AT:
        return _GC_TOKEN

    async with _GC_TOKEN_LOCK:
        now = time.time()
        if (not force_refresh) and _GC_TOKEN and now < _GC_TOKEN_EXPIRES_AT:
            return _GC_TOKEN

        url = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"
        headers = {
            "Authorization": f"Basic {AUTH_KEY}",
            "RqUID": str(uuid.uuid4()),
            "Content-Type": "application/x-www-form-urlencoded",
            "Accept": "application/json",
        }

        async with session.post(
            url,
            headers=headers,
            data={"scope": SCOPE},
            ssl=False,
            timeout=30
        ) as r:
            text = await r.text()
            if r.status != 200:
                raise RuntimeError(text)

        data = json.loads(text)
        token = data["access_token"]

        # 1) –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî expires_in (—Å–µ–∫—É–Ω–¥—ã)
        if "expires_in" in data:
            exp = time.time() + int(data["expires_in"])
        # 2) –∑–∞–ø–∞—Å–Ω–æ–π ‚Äî expires_at (–º–æ–∂–µ—Ç –±—ã—Ç—å epoch –≤ —Å–µ–∫ –∏–ª–∏ –º—Å)
        elif "expires_at" in data:
            raw = int(data["expires_at"])
            # –µ—Å–ª–∏ –ø–æ—Ö–æ–∂–µ –Ω–∞ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã ‚Äî –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–µ–∫—É–Ω–¥—ã
            exp = (raw / 1000) if raw > 10_000_000_000 else raw
        else:
            exp = time.time() + 1800  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 30 –º–∏–Ω—É—Ç

        _GC_TOKEN = token
        _GC_TOKEN_EXPIRES_AT = float(exp) - 30  # –∑–∞–ø–∞—Å 30 —Å–µ–∫
        return _GC_TOKEN



async def gigachat_chat(system_prompt: str, user_text: str) -> str:
    async with aiohttp.ClientSession() as session:
        token = await get_access_token(session)
        payload = {
            "model": MODEL,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_text},
            ],
            "temperature": 0.2,
        }
        async def _call(tkn: str):
            headers = {"Authorization": f"Bearer {tkn}", "Content-Type": "application/json"}
            return await session.post(
                "https://gigachat.devices.sberbank.ru/api/v1/chat/completions",
                headers=headers,
                json=payload,
                timeout=90,
                ssl=False,
            )

        r = await _call(token)
        if r.status == 401:
            await r.release()
            token = await get_access_token(session, force_refresh=True)
            r = await _call(token)

        if r.status != 200:
            raise RuntimeError(await r.text())

        data = await r.json()
        return data["choices"][0]["message"]["content"].strip()



# ---------- admin commands ----------
@dp.message(Command("myid"))
async def myid(message: Message):
    await message.answer(f"–í–∞—à Telegram ID: {message.from_user.id}")


@dp.message(Command("who"))
async def who(message: Message):
    if not is_admin(message.from_user.id):
        return
    allowed = ", ".join(str(x) for x in sorted(ALLOWED_USERS)) if ALLOWED_USERS else "(–ø—É—Å—Ç–æ)"
    admins = ", ".join(str(x) for x in sorted(ADMIN_USERS)) if ADMIN_USERS else "(–ø—É—Å—Ç–æ)"
    await message.answer(f"ALLOWED_USERS: {allowed}\nADMIN_USERS: {admins}")


@dp.message(Command("allow"))
async def allow(message: Message):
    if not is_admin(message.from_user.id):
        return
    parts = (message.text or "").split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π: /allow 123456789")
        return
    uid = int(parts[1])
    ALLOWED_USERS.add(uid)
    if not ADMIN_USERS:
        ADMIN_USERS.add(message.from_user.id)
    _sync_env_from_memory()
    await message.answer(f"‚úÖ –î–æ–±–∞–≤–∏–ª {uid} –≤ –¥–æ—Å—Ç—É–ø.")


@dp.message(Command("deny"))
async def deny(message: Message):
    if not is_admin(message.from_user.id):
        return
    parts = (message.text or "").split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑—É–π: /deny 123456789")
        return
    uid = int(parts[1])
    if uid == message.from_user.id:
        await message.answer("–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è —á–µ—Ä–µ–∑ /deny (—á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø).")
        return
    ALLOWED_USERS.discard(uid)
    ADMIN_USERS.discard(uid)
    _sync_env_from_memory()
    await message.answer(f"‚úÖ –£–±—Ä–∞–ª {uid} –∏–∑ –¥–æ—Å—Ç—É–ø–∞.")


# ---------- main flows ----------
@dp.message(CommandStart())
async def start(message: Message):
    if not is_allowed(message.from_user.id):
        return
    cancel_flow(message.from_user.id)
    await message.answer("–í—ã–±–µ—Ä–∏ –∑–∞–¥–∞—á—É üëá", reply_markup=main_keyboard())


@dp.callback_query()
async def on_callback(call: CallbackQuery):
    uid = call.from_user.id
    if not is_allowed(uid):
        await call.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return

    data = call.data or ""

    if data == "export:word":
        await call.answer()
        text = LAST_RESULT.get(uid)
        if text:
            await call.message.answer(text)
        else:
            await call.message.answer("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å.")
        return

    if data == "mode:motion":
        start_motion(uid)
        await call.message.answer("–í—ã–±–µ—Ä–∏ —Ç–∏–ø —Å—É–¥–∞:", reply_markup=court_type_keyboard())
        await call.answer()
        return

    if data == "mode:settlement":
        start_settlement(uid)
        await call.message.answer("–ê–Ω–∫–µ—Ç–∞ –¥–ª—è –º–∏—Ä–æ–≤–æ–≥–æ. –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —á–µ—Ä–Ω–æ–≤–∏–∫ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç.", reply_markup=settlement_actions_keyboard())
        await call.message.answer(SETTLEMENT_STEPS[0][1], reply_markup=settlement_actions_keyboard())
        await call.answer()
        return

    if data == "mode:qa":
        cancel_flow(uid)
        await call.message.answer("–û–∫. –ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å –ø–æ –±–∞–Ω–∫—Ä–æ—Ç—Å—Ç–≤—É –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.")
        await call.answer()
        return

    if data.startswith("court:") and uid in USER_FLOW and USER_FLOW[uid].get("flow") == "motion":
        ct = data.split(":", 1)[1]
        USER_FLOW[uid]["court_type"] = ct
        USER_FLOW[uid]["stage"] = "fill"
        USER_FLOW[uid]["step"] = 0
        USER_FLOW[uid]["answers"] = {}
        await call.message.answer("–ê–Ω–∫–µ—Ç–∞. –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —á–µ—Ä–Ω–æ–≤–∏–∫ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç.", reply_markup=motion_actions_keyboard())
        await call.message.answer(MOTION_STEPS[0][1], reply_markup=motion_actions_keyboard())
        await call.answer()
        return

    if data == "motion:cancel":
        cancel_flow(uid)
        await call.message.answer("–ê–Ω–∫–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ú–µ–Ω—é üëá", reply_markup=main_keyboard())
        await call.answer()
        return

    if data == "motion:generate_now":
        if uid not in USER_FLOW or USER_FLOW[uid].get("flow") != "motion" or USER_FLOW[uid].get("court_type") is None:
            await call.answer("–ê–Ω–∫–µ—Ç–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞ –∏–ª–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω —Ç–∏–ø —Å—É–¥–∞.", show_alert=True)
            return
        await call.answer()
        await call.message.answer("–ì–æ—Ç–æ–≤–ª—é —á–µ—Ä–Ω–æ–≤–∏–∫‚Ä¶")
        try:
            flow = USER_FLOW[uid]
            user_text = build_motion_user_text(flow.get("answers", {}), flow["court_type"], draft=True)
            result = await gigachat_chat(system_prompt_for_motion(flow["court_type"]), user_text)
            LAST_RESULT[uid] = result
            await call.message.answer(result)
            await call.message.answer("–≠–∫—Å–ø–æ—Ä—Ç üëá", reply_markup=export_keyboard())
        except Exception as e:
            await call.message.answer(f"–û—à–∏–±–∫–∞ GigaChat:\n{e}")
        return

    if data == "settlement:cancel":
        cancel_flow(uid)
        await call.message.answer("–ê–Ω–∫–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ú–µ–Ω—é üëá", reply_markup=main_keyboard())
        await call.answer()
        return

    if data == "settlement:generate_now":
        if uid not in USER_FLOW or USER_FLOW[uid].get("flow") != "settlement":
            await call.answer("–ê–Ω–∫–µ—Ç–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.", show_alert=True)
            return
        await call.answer()
        await call.message.answer("–ì–æ—Ç–æ–≤–ª—é —á–µ—Ä–Ω–æ–≤–∏–∫‚Ä¶")
        try:
            flow = USER_FLOW[uid]
            user_text = build_settlement_user_text(flow.get("answers", {}), draft=True)
            result = await gigachat_chat(system_prompt_for_settlement(), user_text)
            LAST_RESULT[uid] = result
            await call.message.answer(result)
            await call.message.answer("–≠–∫—Å–ø–æ—Ä—Ç üëá", reply_markup=export_keyboard())
        except Exception as e:
            await call.message.answer(f"–û—à–∏–±–∫–∞ GigaChat:\n{e}")
        return

    await call.answer()

from aiogram.filters import Command

@dp.message(~Command())
async def on_message(message: Message):
    uid = message.from_user.id
    if not is_allowed(uid):
        return

    text = (message.text or "").strip()
    if text.startswith("/"):
        return


    if uid not in USER_FLOW:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∑–∞–¥–∞—á—É —á–µ—Ä–µ–∑ /start.")
        return

    flow = USER_FLOW[uid]

    if flow.get("flow") == "motion":
        if flow.get("stage") != "fill":
            await message.answer("–í—ã–±–µ—Ä–∏ —Ç–∏–ø —Å—É–¥–∞ –∫–Ω–æ–ø–∫–æ–π:", reply_markup=court_type_keyboard())
            return

        if text.lower() in {"–æ—Ç–º–µ–Ω–∞", "/cancel", "cancel"}:
            cancel_flow(uid)
            await message.answer("–ê–Ω–∫–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ú–µ–Ω—é üëá", reply_markup=main_keyboard())
            return

        step = int(flow.get("step", 0))
        key = MOTION_STEPS[step][0]
        flow["answers"][key] = text
        step += 1
        flow["step"] = step

        if step < len(MOTION_STEPS):
            await message.answer(MOTION_STEPS[step][1], reply_markup=motion_actions_keyboard())
            return

        await message.answer("–ü—Ä–∏–Ω—è–ª –¥–∞–Ω–Ω—ã–µ. –ì–æ—Ç–æ–≤–ª—é –∏—Ç–æ–≥–æ–≤—ã–π —Ç–µ–∫—Å—Ç‚Ä¶")
        try:
            user_text = build_motion_user_text(flow.get("answers", {}), flow["court_type"], draft=False)
            result = await gigachat_chat(system_prompt_for_motion(flow["court_type"]), user_text)
            LAST_RESULT[uid] = result
            await message.answer(result)
            await message.answer("–≠–∫—Å–ø–æ—Ä—Ç üëá", reply_markup=export_keyboard())
        except Exception as e:
            await message.answer(f"–û—à–∏–±–∫–∞ GigaChat:\n{e}")

        cancel_flow(uid)
        return

    if flow.get("flow") == "settlement":
        if text.lower() in {"–æ—Ç–º–µ–Ω–∞", "/cancel", "cancel"}:
            cancel_flow(uid)
            await message.answer("–ê–Ω–∫–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ú–µ–Ω—é üëá", reply_markup=main_keyboard())
            return

        step = int(flow.get("step", 0))
        key = SETTLEMENT_STEPS[step][0]
        flow["answers"][key] = text
        step += 1
        flow["step"] = step

        if step < len(SETTLEMENT_STEPS):
            await message.answer(SETTLEMENT_STEPS[step][1], reply_markup=settlement_actions_keyboard())
            return

        await message.answer("–ü—Ä–∏–Ω—è–ª –¥–∞–Ω–Ω—ã–µ. –ì–æ—Ç–æ–≤–ª—é –ø—Ä–æ–µ–∫—Ç –º–∏—Ä–æ–≤–æ–≥–æ‚Ä¶")
        try:
            user_text = build_settlement_user_text(flow.get("answers", {}), draft=False)
            result = await gigachat_chat(system_prompt_for_settlement(), user_text)
            LAST_RESULT[uid] = result
            await message.answer(result)
            await message.answer("–≠–∫—Å–ø–æ—Ä—Ç üëá", reply_markup=export_keyboard())
        except Exception as e:
            await message.answer(f"–û—à–∏–±–∫–∞ GigaChat:\n{e}")

        cancel_flow(uid)
        return


async def main():
    bot = Bot(token=BOT_TOKEN)
    await bot.delete_webhook(drop_pending_updates=True)
    cases.init_db()
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
